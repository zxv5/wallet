
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">wallet/docs/docs.go (0.0%)</option>
				
				<option value="file1">wallet/internal/controller/user.go (100.0%)</option>
				
				<option value="file2">wallet/internal/controller/wallet.go (79.2%)</option>
				
				<option value="file3">wallet/internal/dao/dao.go (67.6%)</option>
				
				<option value="file4">wallet/internal/dao/migrations.go (63.6%)</option>
				
				<option value="file5">wallet/internal/dao/user.go (81.0%)</option>
				
				<option value="file6">wallet/internal/dao/wallet.go (70.6%)</option>
				
				<option value="file7">wallet/internal/dao/wallet_record.go (84.0%)</option>
				
				<option value="file8">wallet/internal/gin/core/bind.go (73.7%)</option>
				
				<option value="file9">wallet/internal/gin/core/response.go (70.3%)</option>
				
				<option value="file10">wallet/internal/gin/core/validator.go (78.0%)</option>
				
				<option value="file11">wallet/internal/gin/middleware/cors/cors.go (100.0%)</option>
				
				<option value="file12">wallet/internal/gin/middleware/ignorerr/ignorerr.go (100.0%)</option>
				
				<option value="file13">wallet/internal/gin/middleware/jwt/jwt.go (0.0%)</option>
				
				<option value="file14">wallet/internal/gin/middleware/middleware.go (100.0%)</option>
				
				<option value="file15">wallet/internal/gin/middleware/recovery/recovery.go (68.4%)</option>
				
				<option value="file16">wallet/internal/model/user.go (0.0%)</option>
				
				<option value="file17">wallet/internal/model/wallet.go (0.0%)</option>
				
				<option value="file18">wallet/internal/model/wallet_record.go (0.0%)</option>
				
				<option value="file19">wallet/internal/router/router.go (0.0%)</option>
				
				<option value="file20">wallet/internal/service/service_context.go (100.0%)</option>
				
				<option value="file21">wallet/internal/service/user.go (85.7%)</option>
				
				<option value="file22">wallet/internal/service/wallet.go (79.2%)</option>
				
				<option value="file23">wallet/internal/utils/utils.go (100.0%)</option>
				
				<option value="file24">wallet/main.go (0.0%)</option>
				
				<option value="file25">wallet/pkg/config/setting/setting.go (0.0%)</option>
				
				<option value="file26">wallet/pkg/e/code.go (74.5%)</option>
				
				<option value="file27">wallet/pkg/e/e.go (72.7%)</option>
				
				<option value="file28">wallet/pkg/jwt/jwt.go (92.3%)</option>
				
				<option value="file29">wallet/pkg/logger/level.go (100.0%)</option>
				
				<option value="file30">wallet/pkg/logger/logger.go (70.8%)</option>
				
				<option value="file31">wallet/pkg/logger/zaplog.go (84.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/user/login": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "User Login",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "User Login",
                "parameters": [
                    {
                        "description": "parameter",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/types.UserLoginReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/types.UserLoginOutput"
                        }
                    }
                }
            }
        },
        "/wallet/balance": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get the user's balance",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "Get the user's balance",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/types.BalanceOutput"
                        }
                    }
                }
            }
        },
        "/wallet/deposit": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "User deposits",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "User deposits",
                "parameters": [
                    {
                        "description": "parameter",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/types.DepositReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    }
                }
            }
        },
        "/wallet/record": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get user transaction records",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "Get user transaction records",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "size",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/types.RecordOutput"
                            }
                        }
                    }
                }
            }
        },
        "/wallet/transfer": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "User Transfer",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "User Transfer",
                "parameters": [
                    {
                        "description": "parameter",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/types.TransferReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    }
                }
            }
        },
        "/wallet/withdraw": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "User withdraw",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Wallet"
                ],
                "summary": "User withdraw",
                "parameters": [
                    {
                        "description": "parameter",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/types.WithdrawReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    }
                }
            }
        }
    },
    "definitions": {
        "types.BalanceOutput": {
            "type": "object",
            "properties": {
                "balance": {
                    "type": "number"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "types.DepositReq": {
            "type": "object",
            "properties": {
                "amount": {
                    "description": "Amount to deposit",
                    "type": "number"
                }
            }
        },
        "types.RecordOutput": {
            "type": "object",
            "properties": {
                "amount": {
                    "description": "amount",
                    "type": "number"
                },
                "created_at": {
                    "description": "Creation time",
                    "type": "string"
                },
                "describe": {
                    "description": "description",
                    "type": "string"
                },
                "id": {
                    "description": "wallet record id",
                    "type": "integer"
                },
                "transaction_type": {
                    "description": "transaction type 0=unknown 1=income 2=expend",
                    "type": "integer"
                }
            }
        },
        "types.TransferReq": {
            "type": "object",
            "properties": {
                "amount": {
                    "description": "Amount to transfer",
                    "type": "number"
                },
                "target_user_id": {
                    "description": "Transfer target user ID",
                    "type": "integer"
                }
            }
        },
        "types.UserInfo": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "gender": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "last_name": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "types.UserLoginOutput": {
            "type": "object",
            "properties": {
                "info": {
                    "$ref": "#/definitions/types.UserInfo"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "types.UserLoginReq": {
            "type": "object",
            "properties": {
                "email": {
                    "description": "login email",
                    "type": "string"
                },
                "password": {
                    "description": "login password",
                    "type": "string"
                }
            }
        },
        "types.WithdrawReq": {
            "type": "object",
            "properties": {
                "amount": {
                    "description": "Amount to withdraw",
                    "type": "number"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "description": "Please enter your Bearer token",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0.0",
        Host:             "127.0.0.1:3000",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "wallet",
        Description:      "wallet",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "wallet/internal/gin/core"
        "wallet/internal/service"

        "github.com/gin-gonic/gin"
)

type UserController struct {
        svcCtx *service.ServiceContext
}

func NewUserController(svcCtx *service.ServiceContext) *UserController <span class="cov8" title="1">{
        return &amp;UserController{svcCtx: svcCtx}
}</span>

// Login User Login
// @Summary User Login
// @Description User Login
// @Tags User
// @Accept application/json
// @Produce application/json
// @Param body body types.UserLoginReq true "parameter"
// @Security ApiKeyAuth
// @Success 200 {object} types.UserLoginOutput
// @Router /user/login [POST]
func (ctrl *UserController) Login(c *gin.Context) <span class="cov8" title="1">{
        var form struct {
                Email    string `form:"email" json:"email" binding:"required,email"`
                Password string `form:"password" json:"password" binding:"required"`
        }
        ctx := core.New(c).Bind(&amp;form)

        userService := service.NewUserService(c, ctrl.svcCtx)
        output, err := userService.Login(form.Email, form.Password)
        if err != nil </span><span class="cov8" title="1">{
                ctx.SendErr(err)
                return
        }</span>

        <span class="cov8" title="1">ctx.SendOk(output)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "wallet/internal/gin/core"
        "wallet/internal/service"
        "wallet/internal/types"
        "wallet/internal/utils"

        "github.com/gin-gonic/gin"
)

type walletController struct {
        svcCtx *service.ServiceContext
}

func NewWalletController(svcCtx *service.ServiceContext) *walletController <span class="cov8" title="1">{
        return &amp;walletController{svcCtx: svcCtx}
}</span>

// Deposit User deposits
// @Summary User deposits
// @Description User deposits
// @Tags Wallet
// @Accept application/json
// @Produce application/json
// @Param body body types.DepositReq true "parameter"
// @Security ApiKeyAuth
// @Success 200
// @Router /wallet/deposit [POST]
func (ctrl *walletController) Deposit(c *gin.Context) <span class="cov8" title="1">{
        var form struct {
                Amount float64 `form:"amount" json:"amount" binding:"required,gt=0,max=9999999999"`
        }
        var userInfo types.UserInfo
        ctx := core.New(c).Bind(&amp;form).BindUserInfo(&amp;userInfo)

        in := &amp;types.DepositInput{
                UserID: userInfo.ID,
                Amount: form.Amount,
        }
        walletService := service.NewWalletService(c, ctrl.svcCtx)
        if err := walletService.Deposit(in); err != nil </span><span class="cov0" title="0">{
                ctx.SendErr(err)
                return
        }</span>

        <span class="cov8" title="1">ctx.SendOk()</span>
}

// Withdraw User withdraw
// @Summary User withdraw
// @Description User withdraw
// @Tags Wallet
// @Accept application/json
// @Produce application/json
// @Param body body types.WithdrawReq true "parameter"
// @Security ApiKeyAuth
// @Success 200
// @Router /wallet/withdraw [POST]
func (ctrl *walletController) Withdraw(c *gin.Context) <span class="cov8" title="1">{
        var form struct {
                Amount float64 `form:"amount" json:"amount" binding:"required,gt=0,max=9999999999"`
        }
        var userInfo types.UserInfo
        ctx := core.New(c).Bind(&amp;form).BindUserInfo(&amp;userInfo)

        in := &amp;types.WithdrawInput{
                UserID: userInfo.ID,
                Amount: form.Amount,
        }
        walletService := service.NewWalletService(c, ctrl.svcCtx)
        if err := walletService.Withdraw(in); err != nil </span><span class="cov0" title="0">{
                ctx.SendErr(err)
                return
        }</span>

        <span class="cov8" title="1">ctx.SendOk()</span>
}

// Transfer User Transfer
// @Summary User Transfer
// @Description User Transfer
// @Tags Wallet
// @Accept application/json
// @Produce application/json
// @Param body body types.TransferReq true "parameter"
// @Security ApiKeyAuth
// @Success 200
// @Router /wallet/transfer [POST]
func (ctrl *walletController) Transfer(c *gin.Context) <span class="cov8" title="1">{
        var form struct {
                Amount       float64 `form:"amount" json:"amount" binding:"required,gt=0,max=9999999999"`
                TargetUserID int64   `form:"target_user_id" json:"target_user_id" binding:"required"`
        }
        var userInfo types.UserInfo
        ctx := core.New(c).Bind(&amp;form).BindUserInfo(&amp;userInfo)

        in := &amp;types.TransferInput{
                UserID:       userInfo.ID,
                FirstName:    userInfo.FirstName,
                LastName:     userInfo.LastName,
                TargetUserID: form.TargetUserID,
                Amount:       form.Amount,
        }
        walletService := service.NewWalletService(c, ctrl.svcCtx)
        if err := walletService.Transfer(in); err != nil </span><span class="cov0" title="0">{
                ctx.SendErr(err)
                return
        }</span>

        <span class="cov8" title="1">ctx.SendOk()</span>
}

// Balance Get the user's balance
// @Summary Get the user's balance
// @Description Get the user's balance
// @Tags Wallet
// @Accept application/json
// @Produce application/json
// @Security ApiKeyAuth
// @Success 200 {object} types.BalanceOutput
// @Router /wallet/balance [GET]
func (ctrl *walletController) Balance(c *gin.Context) <span class="cov8" title="1">{
        var userInfo types.UserInfo
        ctx := core.New(c).BindUserInfo(&amp;userInfo)

        in := &amp;types.BalanceInput{
                UserID: userInfo.ID,
        }
        walletService := service.NewWalletService(c, ctrl.svcCtx)
        output, err := walletService.Balance(in)
        if err != nil </span><span class="cov0" title="0">{
                ctx.SendErr(err)
                return
        }</span>

        <span class="cov8" title="1">ctx.SendOk(output)</span>
}

// Record Get user transaction records
// @Summary Get user transaction records
// @Description Get user transaction records
// @Tags Wallet
// @Accept application/json
// @Produce application/json
// @Param query query types.RecordReq true "parameter"
// @Security ApiKeyAuth
// @Success 200 {array} types.RecordOutput
// @Router /wallet/record [GET]
func (ctrl *walletController) Record(c *gin.Context) <span class="cov8" title="1">{
        var query struct {
                Page int64 `form:"page" binding:"omitempty"`
                Size int64 `form:"size" binding:"omitempty"`
        }
        var userInfo types.UserInfo
        ctx := core.New(c).BindQuery(&amp;query).BindUserInfo(&amp;userInfo)

        offset, limit := utils.GetOffsetLimit(query.Page, query.Size)

        in := &amp;types.RecordInput{
                UserID: userInfo.ID,
                Offset: offset,
                Limit:  limit,
        }
        walletService := service.NewWalletService(c, ctrl.svcCtx)
        output, total, err := walletService.Record(in)
        if err != nil </span><span class="cov0" title="0">{
                ctx.SendErr(err)
                return
        }</span>

        <span class="cov8" title="1">ctx.Append("total", total).SendOk(output)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package dao

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "wallet/internal/config"

        "wallet/pkg/e"
)

type ctxTransactionKey struct{}

type Dao struct {
        config *config.Config
        *sql.DB
}

func NewDao(c *config.Config) *Dao <span class="cov8" title="1">{
        dbConfig := c.DBCfg
        createDatabaseIfNotExists(&amp;dbConfig)

        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%d sslmode=disable TimeZone=UTC",
                dbConfig.Host, dbConfig.User, dbConfig.Password, dbConfig.DBName, dbConfig.Port)

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("open postgresql fail: %v", err)
        }</span>

        <span class="cov8" title="1">db.SetMaxIdleConns(dbConfig.MaxIdleConns)
        db.SetMaxOpenConns(dbConfig.MaxOpenConns)

        migrations(db, dbConfig.MigrationsPath)

        return &amp;Dao{
                config: c,
                DB:     db,
        }</span>
}

// Define a unified database interface
type Database interface {
        QueryRow(query string, args ...interface{}) *sql.Row
        Query(query string, args ...interface{}) (*sql.Rows, error)
        Exec(query string, args ...any) (sql.Result, error)
}

// DBWrapper is used to encapsulate *sql.DB
type DBWrapper struct {
        *sql.DB
}

// TxWrapper is used to encapsulate *sql.Tx
type TxWrapper struct {
        *sql.Tx
}

func (db *DBWrapper) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov8" title="1">{
        return db.DB.QueryRow(query, args...)
}</span>

func (tx *TxWrapper) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        return tx.Tx.QueryRow(query, args...)
}</span>

func (db *DBWrapper) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov8" title="1">{
        return db.DB.Query(query, args...)
}</span>

func (tx *TxWrapper) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        return tx.Tx.Query(query, args...)
}</span>

func (db *DBWrapper) Exec(query string, args ...any) (sql.Result, error) <span class="cov8" title="1">{
        return db.DB.Exec(query, args...)
}</span>

func (tx *TxWrapper) Exec(query string, args ...any) (sql.Result, error) <span class="cov0" title="0">{
        return tx.Tx.Exec(query, args...)
}</span>

func (dao *Dao) WithContext(ctx context.Context) Database <span class="cov8" title="1">{
        iface := ctx.Value(ctxTransactionKey{})

        if iface != nil </span><span class="cov0" title="0">{
                if tx, ok := iface.(*sql.Tx); ok </span><span class="cov0" title="0">{
                        return &amp;TxWrapper{tx} // Returns the transaction wrapper
                }</span>
        }

        <span class="cov8" title="1">return &amp;DBWrapper{dao.DB}</span> // Returns the database wrapper

}

func (dao *Dao) Transaction(ctx context.Context, runInTransaction func(ctx context.Context) e.Codes) e.Codes <span class="cov8" title="1">{
        iface := ctx.Value(ctxTransactionKey{})

        if iface != nil </span><span class="cov0" title="0">{
                if tx, ok := iface.(*sql.Tx); ok </span><span class="cov0" title="0">{
                        if err := runInTransaction(ctx); err != nil </span><span class="cov0" title="0">{
                                tx.Rollback()
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        <span class="cov8" title="1">tx, err := dao.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return e.SQLErr
        }</span>

        <span class="cov8" title="1">ctx = context.WithValue(ctx, ctxTransactionKey{}, tx)

        if err := runInTransaction(ctx); err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">tx.Commit()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package dao

import (
        "database/sql"
        "fmt"
        "wallet/internal/config"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/lib/pq"
)

func createDatabaseIfNotExists(dbConfig *config.DBCfg) <span class="cov8" title="1">{
        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=template1 port=%d sslmode=disable TimeZone=UTC",
                dbConfig.Host, dbConfig.User, dbConfig.Password, dbConfig.Port)

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">defer db.Close()

        var exists bool
        query := `SELECT EXISTS (SELECT 1 FROM pg_database WHERE datname = $1);`

        err = db.QueryRow(query, dbConfig.DBName).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                panic("Unable to create database if not exists")</span>
        }

        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                _, err := db.Exec("CREATE DATABASE " + dbConfig.DBName + " ENCODING 'UTF8' LC_COLLATE = 'en_US.utf8' LC_CTYPE = 'en_US.utf8' TEMPLATE = template0;")
                if err != nil </span><span class="cov0" title="0">{
                        panic("Unable to create database if not exists")</span>
                }
        }
}

func migrations(db *sql.DB, filePath string) <span class="cov8" title="1">{
        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                panic("Migrations WithInstance error" + err.Error())</span>
        }

        <span class="cov8" title="1">m, err := migrate.NewWithDatabaseInstance("file://"+filePath, "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                panic("Migrations error" + err.Error())</span>
        }

        <span class="cov8" title="1">if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                panic("Migrations Up error" + err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dao

import (
        "context"
        "database/sql"
        "wallet/internal/model"
        "wallet/pkg/e"
        "wallet/pkg/logger"
)

type User struct {
        dao *Dao
}

func NewUser(dao *Dao) *User <span class="cov8" title="1">{
        return &amp;User{dao: dao}
}</span>

func (d *User) FindOneByID(ctx context.Context, userID int64) (*model.User, e.Codes) <span class="cov8" title="1">{
        var user model.User

        query := `SELECT "id", "email", "password", "first_name", "last_name", "gender", "status", "created_at" FROM "user" WHERE "id" = $1;`
        row := d.dao.WithContext(ctx).QueryRow(query, userID)

        err := row.Scan(&amp;user.ID, &amp;user.Email, &amp;user.Password, &amp;user.FirstName, &amp;user.LastName, &amp;user.Gender, &amp;user.Status, &amp;user.CreatedAt)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, e.NotFound
                }</span>
                <span class="cov0" title="0">logger.Errorf("failed to find user: %w", err)
                return nil, e.SQLErr</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (d *User) FindOneByEmail(ctx context.Context, email string) (*model.User, e.Codes) <span class="cov8" title="1">{
        var user model.User

        query := `SELECT "id", "email", "password", "first_name", "last_name", "gender", "status", "created_at" FROM "user" WHERE "email" = $1;`
        row := d.dao.WithContext(ctx).QueryRow(query, email)

        err := row.Scan(&amp;user.ID, &amp;user.Email, &amp;user.Password, &amp;user.FirstName, &amp;user.LastName, &amp;user.Gender, &amp;user.Status, &amp;user.CreatedAt)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, e.NotFound
                }</span>
                <span class="cov0" title="0">logger.Errorf("failed to find user: %w", err)
                return nil, e.SQLErr</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package dao

import (
        "context"
        "database/sql"
        "wallet/internal/model"
        "wallet/pkg/e"
        "wallet/pkg/logger"
)

type Wallet struct {
        dao *Dao
}

func NewWallet(dao *Dao) *Wallet <span class="cov8" title="1">{
        return &amp;Wallet{dao: dao}
}</span>

func (d *Wallet) FindOneByUserID(ctx context.Context, userID int64) (*model.Wallet, e.Codes) <span class="cov8" title="1">{
        var wallet model.Wallet

        query := `SELECT "id", "balance" FROM "wallet" WHERE "user_id" = $1;`
        row := d.dao.WithContext(ctx).QueryRow(query, userID)

        err := row.Scan(&amp;wallet.ID, &amp;wallet.Balance)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, e.NotFound
                }</span>
                <span class="cov0" title="0">logger.Errorf("failed to find wallet: %w", err)
                return nil, e.SQLErr</span>
        }

        <span class="cov8" title="1">return &amp;wallet, nil</span>
}

// FindOneByUserIDForUpdate finds a wallet by user ID and locks it for update.
func (d *Wallet) FindOneByUserIDForUpdate(ctx context.Context, userID int64) (*model.Wallet, e.Codes) <span class="cov8" title="1">{
        var wallet model.Wallet

        query := `SELECT "id", "balance" FROM "wallet" WHERE "user_id" = $1 FOR UPDATE;`
        row := d.dao.WithContext(ctx).QueryRow(query, userID)

        err := row.Scan(&amp;wallet.ID, &amp;wallet.Balance)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, e.NotFound
                }</span>
                <span class="cov0" title="0">logger.Errorf("failed to find wallet: %w", err)
                return nil, e.SQLErr</span>
        }

        <span class="cov8" title="1">return &amp;wallet, nil</span>
}

// UpdateBalanceByUserID Update wallet balance by user
func (d *Wallet) UpdateBalanceByUserID(ctx context.Context, userID int64, newBalance float64) e.Codes <span class="cov8" title="1">{
        query := `UPDATE "wallet" SET "balance" = $1 WHERE "user_id" = $2;`
        result, err := d.dao.WithContext(ctx).Exec(query, newBalance, userID)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to update wallet: %w", err)
                return e.SQLErr
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to get rows affected: %w", err)
                return e.SQLErr
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                logger.Errorf("no wallet found with userID %d", userID)
                return e.SQLErr
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package dao

import (
        "context"
        "wallet/internal/consts"
        "wallet/internal/model"
        "wallet/pkg/e"
)

type WalletRecord struct {
        dao *Dao
}

func NewWalletRecord(dao *Dao) *WalletRecord <span class="cov8" title="1">{
        return &amp;WalletRecord{dao: dao}
}</span>

func (d *WalletRecord) FindListAndCountByWalletID(ctx context.Context, walletID, offset, limit int64) ([]*model.WalletRecord, int64, e.Codes) <span class="cov8" title="1">{
        query := `SELECT "id", "wallet_id", "amount", "transaction_type", "describe", "created_at" FROM "wallet_record"
        WHERE "wallet_id" = $1 and "deleted" = $2 ORDER BY "created_at" DESC OFFSET $3 LIMIT $4;`

        rows, err := d.dao.WithContext(ctx).Query(query, walletID, consts.NotDeleted, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, e.SQLErr
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var walletRecords []*model.WalletRecord
        for rows.Next() </span><span class="cov8" title="1">{
                var walletRecord model.WalletRecord
                if err := rows.Scan(
                        &amp;walletRecord.ID,
                        &amp;walletRecord.WalletID,
                        &amp;walletRecord.Amount,
                        &amp;walletRecord.TransactionType,
                        &amp;walletRecord.Describe,
                        &amp;walletRecord.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, e.SQLErr
                }</span>
                <span class="cov8" title="1">walletRecords = append(walletRecords, &amp;walletRecord)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, e.SQLErr
        }</span>

        <span class="cov8" title="1">var totalCount int64
        countQuery := `SELECT count(*) as count FROM "wallet_record" WHERE "wallet_id" = $1 AND "deleted" = $2`

        err = d.dao.WithContext(ctx).QueryRow(countQuery, walletID, consts.NotDeleted).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, e.SQLErr
        }</span>

        <span class="cov8" title="1">return walletRecords, totalCount, nil</span>
}

func (d *WalletRecord) Create(ctx context.Context, walletRecord *model.WalletRecord) e.Codes <span class="cov8" title="1">{
        query := `INSERT INTO "wallet_record" ("wallet_id", "amount", "transaction_type", "describe") VALUES ($1, $2, $3, $4)`

        _, err := d.dao.WithContext(ctx).Exec(query, walletRecord.WalletID, walletRecord.Amount, walletRecord.TransactionType, walletRecord.Describe)
        if err != nil </span><span class="cov8" title="1">{
                return e.SQLErr
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package core

import (
        "errors"
        "reflect"
        "wallet/internal/types"
        "wallet/pkg/e"
        "wallet/pkg/logger"
)

// BindWidth .
func (c *Context) BindWidth(form interface{}, f func(obj interface{}) error) *Context <span class="cov8" title="1">{
        if reflect.TypeOf(form).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                c.SendPanic(errors.New("Bind Error, Must Ptr"), e.CheckErr)
        }</span>

        <span class="cov8" title="1">if err := f(form); err != nil </span><span class="cov0" title="0">{
                logger.Warnf("BindWidth validator Error: %s", err.Error())
                msg := GetValidationError(err, form)
                c.SendPanic(errors.New("Bind Error"), e.ParamsErr, msg)
        }</span>

        <span class="cov8" title="1">return c</span>
}

// Bind .
func (c *Context) Bind(form interface{}) *Context <span class="cov8" title="1">{
        return c.BindWidth(form, c.C.ShouldBind)
}</span>

// BindQuery .
func (c *Context) BindQuery(form interface{}) *Context <span class="cov8" title="1">{
        return c.BindWidth(form, c.C.ShouldBindQuery)
}</span>

// BindUri .
func (c *Context) BindUri(form interface{}) *Context <span class="cov8" title="1">{
        return c.BindWidth(form, c.C.ShouldBindUri)
}</span>

// BindUserInfo
func (c *Context) BindUserInfo(form *types.UserInfo) *Context <span class="cov8" title="1">{
        if userInfo, ok := c.C.Get("__userinfo"); ok </span><span class="cov8" title="1">{
                form.ID = userInfo.(types.UserInfo).ID
                form.FirstName = userInfo.(types.UserInfo).FirstName
                form.LastName = userInfo.(types.UserInfo).LastName
                form.Gender = userInfo.(types.UserInfo).Gender
                form.Status = userInfo.(types.UserInfo).Status
                form.CreatedAt = userInfo.(types.UserInfo).CreatedAt
        }</span> else<span class="cov0" title="0"> {
                c.SendPanic(e.AuthErr)
        }</span>

        <span class="cov8" title="1">return c</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package core

import (
        "net/http"
        "reflect"
        "wallet/pkg/e"
        "wallet/pkg/logger"

        "github.com/gin-gonic/gin"
)

const _BusinessResponse = "_business_response_"
const ExtraProperty = "_extraProperty_"

// response .
type response struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data"`
}

// Context .
type Context struct {
        C        *gin.Context
        httpCode int
        response *response
}

// New .
func New(c *gin.Context) *Context <span class="cov8" title="1">{
        res := response{}
        return &amp;Context{C: c, response: &amp;res}
}</span>

// HttpCode .
func (c *Context) HttpCode(httpCode int) *Context <span class="cov8" title="1">{
        c.httpCode = httpCode
        return c
}</span>

// Code .
func (c *Context) Code(code e.Code) *Context <span class="cov8" title="1">{
        c.response.Code = code.Code()
        c.response.Message = code.Message()
        return c
}</span>

// Message .
func (c *Context) Message(message string) *Context <span class="cov8" title="1">{
        c.response.Message = message
        return c
}</span>

// Data .
func (c *Context) Data(data interface{}) *Context <span class="cov0" title="0">{
        c.response.Data = data
        return c
}</span>

// success Normal return
func (c *Context) success(data ...interface{}) <span class="cov8" title="1">{
        if c.httpCode == 0 </span><span class="cov8" title="1">{
                c.httpCode = 200
        }</span>

        <span class="cov8" title="1">if c.response.Code == 0 </span><span class="cov8" title="1">{
                c.response.Code = 200
        }</span>

        <span class="cov8" title="1">if len(data) &gt; 0 </span><span class="cov8" title="1">{
                c.response.Data = data[0]
        }</span>

        <span class="cov8" title="1">if len(data) &gt; 1 </span><span class="cov0" title="0">{
                logger.Warn("Too many arguments in call to success...", data)
        }</span>

        <span class="cov8" title="1">if c.response.Data == nil </span><span class="cov0" title="0">{
                c.response.Data = gin.H{}
        }</span>

        <span class="cov8" title="1">res := gin.H{"code": c.response.Code, "data": c.response.Data}

        value := c.C.GetStringMap(ExtraProperty)
        for k, v := range value </span><span class="cov0" title="0">{
                res[k] = v
        }</span>

        <span class="cov8" title="1">c.C.JSON(c.httpCode, res)</span>
}

// fail Exception Return
func (c *Context) fail(params ...interface{}) <span class="cov8" title="1">{
        c.errMsg(params...)

        if c.httpCode == 0 </span><span class="cov0" title="0">{
                c.httpCode = 200
        }</span>

        <span class="cov8" title="1">if c.response.Code == 0 </span><span class="cov0" title="0">{
                c.Code(e.ServerErr)
        }</span>

        // logger.Warnf("http://%s%s -&gt; Response Error: %+v =&gt; Params: %+v", c.C.Request.Host, c.C.Request.URL.Path, *c.response, params)

        <span class="cov8" title="1">c.C.Set(_BusinessResponse, c.response)

        res := gin.H{"code": c.response.Code, "message": c.response.Message}
        c.C.AbortWithStatusJSON(c.httpCode, res)</span>
}

/**
 * response success
 */

// SendOk .
func (c *Context) SendOk(data ...interface{}) <span class="cov8" title="1">{
        c.success(data...)
}</span>

// CreateOk .
func (c *Context) CreateOk(data ...interface{}) <span class="cov0" title="0">{
        c.Code(201).success(data...)
}</span>

// DeleteOk .
func (c *Context) DeleteOk(data ...interface{}) <span class="cov0" title="0">{
        c.Code(204).success(data...)
}</span>

/**
 * response error
 */

// SendErr .
func (c *Context) SendErr(params ...interface{}) <span class="cov8" title="1">{
        c.HttpCode(http.StatusBadRequest).fail(params...)
}</span>

// SendNotLogin .
func (c *Context) SendNotLogin(params ...interface{}) <span class="cov0" title="0">{
        args := append(params, e.AuthErr)
        c.HttpCode(http.StatusUnauthorized).fail(args...)
}</span>

// SendNotRole .
func (c *Context) SendNotRole(params ...interface{}) <span class="cov0" title="0">{
        args := append(params, e.PermissionDenied)
        c.HttpCode(http.StatusForbidden).fail(args...)
}</span>

// SendNotFound .
func (c *Context) SendNotFound(params ...interface{}) <span class="cov8" title="1">{
        args := append(params, e.NotFound)
        c.HttpCode(http.StatusNotFound).fail(args...)
}</span>

// SendPanic .
func (c *Context) SendPanic(err error, params ...interface{}) <span class="cov0" title="0">{
        c.C.Set("ignorePainc", true)
        c.HttpCode(http.StatusInternalServerError).fail(params...)
        panic(err)</span>
}

// Append Return to the extended field
func (c *Context) Append(key string, val interface{}) *Context <span class="cov8" title="1">{
        value := c.C.GetStringMap(ExtraProperty)
        if value == nil </span><span class="cov8" title="1">{
                value = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">value[key] = val

        c.C.Set(ExtraProperty, value)
        return c</span>
}

// errMsg Error message handling
func (c *Context) errMsg(codeWithMsg ...interface{}) <span class="cov8" title="1">{
        code, message, l := e.ServerErr, "", len(codeWithMsg)
        if c.response.Code != 0 </span><span class="cov0" title="0">{
                code = e.Int(c.response.Code)
        }</span>

        <span class="cov8" title="1">for _, value := range codeWithMsg </span><span class="cov8" title="1">{
                switch value := value.(type) </span>{
                case e.Codes:<span class="cov8" title="1">
                        code = e.Code(value.Code())
                        message = value.Message()
                        continue</span>
                case error:<span class="cov0" title="0">
                        message = value.Error()
                        continue</span>
                }

                <span class="cov8" title="1">v := reflect.ValueOf(value)
                switch v.Kind() </span>{
                case reflect.Int:<span class="cov0" title="0">
                        code = e.Code(v.Int())</span>
                case reflect.String:<span class="cov8" title="1">
                        message = v.String()</span>
                default:<span class="cov0" title="0">
                        logger.Warn("errMsg arguments must be Error, Codes, Int or String...", codeWithMsg)</span>
                }
        }

        <span class="cov8" title="1">if l &gt; 3 </span><span class="cov0" title="0">{
                logger.Warn("Too many arguments in call to errMsg...", codeWithMsg)
        }</span>

        <span class="cov8" title="1">if code != 0 </span><span class="cov8" title="1">{
                c.Code(code)
        }</span>

        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                c.Message(message)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package core

import (
        "database/sql/driver"
        "reflect"
        "strings"

        "github.com/go-playground/validator/v10"
)

// ValidateValuer .
func ValidateValuer(field reflect.Value) interface{} <span class="cov8" title="1">{
        if valuer, ok := field.Interface().(driver.Valuer); ok </span><span class="cov0" title="0">{
                val, err := valuer.Value()
                if err == nil </span><span class="cov0" title="0">{
                        return val
                }</span>
                // handle the error how you want
        }

        <span class="cov8" title="1">return nil</span>
}

// GetValidationError .
func GetValidationError(err error, form interface{}) string <span class="cov8" title="1">{
        var vErrors = make(map[string]string)

        verrs, ok := err.(validator.ValidationErrors)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">for _, verr := range verrs </span><span class="cov8" title="1">{
                vErrors[verr.Field()] = verr.Tag()
        }</span>

        <span class="cov8" title="1">t := reflect.TypeOf(form)
        if t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">var message string
        if t.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                        sField := t.Field(i)
                        msg := sField.Tag.Get("msg")

                        if tag, exist := vErrors[sField.Name]; exist </span><span class="cov8" title="1">{
                                message = getTagMessage(msg, tag)
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return message</span>
}

// getTagMessage .
func getTagMessage(msg string, key string) string <span class="cov8" title="1">{
        mapping := make(map[string]string)
        strArr := strings.Split(msg, ",")
        if key == "" </span><span class="cov0" title="0">{
                key = "__common"
        }</span>

        <span class="cov8" title="1">for _, val := range strArr </span><span class="cov8" title="1">{
                kv := strings.Split(val, ":")
                if len(kv) == 0 </span><span class="cov0" title="0">{
                        return ""
                }</span>

                <span class="cov8" title="1">if len(kv) &gt;= 2 </span><span class="cov8" title="1">{
                        mapping[kv[0]] = kv[1]
                }</span> else<span class="cov8" title="1"> {
                        mapping["__common"] = kv[0]
                }</span>
        }

        <span class="cov8" title="1">val, ok := mapping[key]
        if ok </span><span class="cov8" title="1">{
                return val
        }</span>

        <span class="cov8" title="1">return mapping["__common"]</span>
}

var defaultFuncs = make(map[string]validator.Func)

// RegisterValidation .
func RegisterValidation(validate *validator.Validate) <span class="cov0" title="0">{
        for k, f := range defaultFuncs </span><span class="cov0" title="0">{
                if err := validate.RegisterValidation(k, f); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        // v.RegisterAlias("id", "email")
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cors

import (
        "net/http"
        "regexp"

        "github.com/gin-gonic/gin"
)

// Cors Cross-domain processing
func Cors() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                method := c.Request.Method
                origin := c.Request.Header.Get("Origin")

                filterHost := [...]string{"http://localhost*", "http://127.0.0.1*"}
                isAccess := false
                for _, v := range filterHost </span><span class="cov8" title="1">{
                        match, _ := regexp.MatchString(v, origin)
                        if match </span><span class="cov8" title="1">{
                                isAccess = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if isAccess </span><span class="cov8" title="1">{
                        // c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                        // This is a allowed access domain.
                        c.Header("Access-Control-Allow-Origin", origin)
                        c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PATCH, PUT, DELETE, UPDATE")
                        c.Header("Access-Control-Allow-Headers", "Authorization, Content-Length, X-CSRF-Token, Token, session, X_Requested_With, Accept, Origin, Host, Connection, Accept-Encoding, Accept-Language, DNT, X-CustomHeader, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type, Pragma")
                        c.Header("Access-Control-Expose-Headers", "Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers,Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma,FooBar")
                        c.Header("Access-Control-Max-Age", "172800")
                        c.Header("Access-Control-Allow-Credentials", "true")
                        c.Set("content-type", "application/json")
                }</span>

                <span class="cov8" title="1">if method == "OPTIONS" </span><span class="cov8" title="1">{
                        c.AbortWithStatus(http.StatusNoContent)
                }</span>
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package ignorerr

import (
        "wallet/pkg/logger"

        "github.com/gin-gonic/gin"
)

// Ignorerr Ignore panic return
func Ignorerr() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if c.GetBool("ignorePainc") </span><span class="cov8" title="1">{
                                if err := recover(); err != nil </span><span class="cov8" title="1">{
                                        logger.Warnf("Ignore Panic-&gt; %+v", err)
                                }</span>
                        }
                }()

                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package jwt

import (
        "strconv"
        "strings"
        "time"
        "wallet/internal/config"
        "wallet/internal/gin/core"
        "wallet/internal/types"
        "wallet/pkg/jwt"

        "github.com/gin-gonic/gin"
        jwtv5 "github.com/golang-jwt/jwt/v5"
)

// UserInfoKey User information key
const UserInfoKey string = "__userinfo"

// Jwt gin middleware
func Jwt(c *config.Jwt) gin.HandlerFunc <span class="cov0" title="0">{
        config := jwt.Config{Secret: c.Secret}

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                ctx := core.New(c)

                authorization := c.GetHeader("Authorization")
                if len(authorization) == 0 </span><span class="cov0" title="0">{
                        ctx.SendNotLogin()
                        return
                }</span>

                <span class="cov0" title="0">arr := strings.Split(authorization, " ")
                if len(arr) != 2 </span><span class="cov0" title="0">{
                        ctx.SendNotLogin()
                        return
                }</span>

                <span class="cov0" title="0">tokenS := arr[1]
                wrap := jwt.New(&amp;types.UserJwtClaims{}, config)

                token, err := wrap.Parse(tokenS)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.SendNotLogin()
                        return
                }</span>

                <span class="cov0" title="0">if cl, ok := token.Claims.(*types.UserJwtClaims); ok </span><span class="cov0" title="0">{
                        c.Set(UserInfoKey, cl.UserInfo)
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">ctx.SendNotLogin()</span>
        }
}

// Sign .
func Sign(c *config.Jwt, userInfo *types.UserInfo) (string, error) <span class="cov0" title="0">{
        config := jwt.Config{Secret: c.Secret}

        claims := &amp;types.UserJwtClaims{
                RegisteredClaims: jwtv5.RegisteredClaims{
                        Subject:   strconv.Itoa(int(userInfo.ID)),
                        ExpiresAt: jwtv5.NewNumericDate(time.Now().Add(time.Hour * time.Duration(c.Exp))),
                },
                UserInfo: *userInfo,
        }

        wrap := jwt.New(claims, config)

        str, err := wrap.Sign()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return str, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "wallet/internal/gin/middleware/cors"
        "wallet/internal/gin/middleware/ignorerr"
        "wallet/internal/gin/middleware/recovery"
        "wallet/pkg/logger"

        "github.com/gin-gonic/gin"
)

func Base() []gin.HandlerFunc <span class="cov8" title="1">{
        return []gin.HandlerFunc{
                gin.Logger(),
                recovery.Recovery(logger.Logger, true),
                ignorerr.Ignorerr(),
                cors.Cors(),
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package recovery

import (
        "net"
        "net/http"
        "net/http/httputil"
        "os"
        "runtime/debug"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// Recovery returns a gin.HandlerFunc (middleware)
// that recovers from any panics and logs requests using uber-go/zap.
// All errors are logged using zap.Error().
// stack means whether output the stack info.
// The stack info is easy to find where the error occurs but the stack info is too large.
func Recovery(logger *zap.SugaredLogger, stack bool) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                // Check for a broken connection, as it is not really a
                                // condition that warrants a panic stack trace.
                                var brokenPipe bool
                                if ne, ok := err.(*net.OpError); ok </span><span class="cov8" title="1">{
                                        if se, ok := ne.Err.(*os.SyscallError); ok </span><span class="cov8" title="1">{
                                                if strings.Contains(strings.ToLower(se.Error()), "broken pipe") || strings.Contains(strings.ToLower(se.Error()), "connection reset by peer") </span><span class="cov0" title="0">{
                                                        brokenPipe = true
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">httpRequest, _ := httputil.DumpRequest(c.Request, false)
                                if brokenPipe </span><span class="cov0" title="0">{
                                        logger.Errorf("%s %+v %s", c.Request.URL.Path, err, string(httpRequest))

                                        // If the connection is dead, we can't write a status to it.
                                        c.Error(err.(error)) // nolint: errcheck
                                        c.Abort()
                                        return
                                }</span>

                                <span class="cov8" title="1">if stack </span><span class="cov8" title="1">{
                                        logger.Errorf("[Recovery from panic] %+v %s \n%s", err, string(httpRequest), string(debug.Stack()))
                                }</span> else<span class="cov0" title="0"> {
                                        logger.Errorf("[Recovery from panic] %+v %s", err, string(httpRequest))
                                }</span>
                                <span class="cov8" title="1">c.AbortWithStatus(http.StatusInternalServerError)</span>
                        }
                }()
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package model

import (
        "time"
)

const TableNameUser = "user"

// User mapped from table &lt;user&gt;
type User struct {
        ID        int64     `json:"id"`
        Email     string    `json:"email"`
        Password  string    `json:"-"`
        FirstName string    `json:"first_name"`
        LastName  string    `json:"last_name"`
        Gender    int64     `json:"gender"`
        Status    int64     `json:"status"` // 0=active 1=inactive 2=suspens
        Deleted   int64     `json:"deleted"`
        UpdatedAt time.Time `json:"updated_at"`
        CreatedAt time.Time `json:"created_at"`
}

// TableName User's table name
func (*User) TableName() string <span class="cov0" title="0">{
        return TableNameUser
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package model

import (
        "time"
)

const TableNameWallet = "wallet"

// Wallet mapped from table &lt;wallet&gt;
type Wallet struct {
        ID        int64     `json:"id"`
        UserID    int64     `json:"user_id"`
        Balance   float64   `json:"balance"`
        Deleted   int64     `json:"deleted"`
        UpdatedAt time.Time `json:"updated_at"`
        CreatedAt time.Time `json:"created_at"`
}

// TableName Wallet's table name
func (*Wallet) TableName() string <span class="cov0" title="0">{
        return TableNameWallet
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package model

import (
        "time"
)

const TableNameWalletRecord = "wallet_record"

// WalletRecord mapped from table &lt;wallet_record&gt;
type WalletRecord struct {
        ID              int64     `json:"id"`
        WalletID        int64     `json:"wallet_id"`
        Amount          float64   `json:"amount"`
        TransactionType int64     `json:"transaction_type"` // 0=unknown 1=income 2=expend
        Describe        *string   `json:"describe"`
        Deleted         int64     `json:"deleted"`
        UpdatedAt       time.Time `json:"updated_at"`
        CreatedAt       time.Time `json:"created_at"`
}

// TableName WalletRecord's table name
func (*WalletRecord) TableName() string <span class="cov0" title="0">{
        return TableNameWalletRecord
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package router

import (
        "os"
        "wallet/internal/config"
        "wallet/internal/controller"
        "wallet/internal/gin/middleware"
        "wallet/internal/gin/middleware/jwt"
        "wallet/internal/service"

        _ "wallet/docs"

        swaggerFiles "github.com/swaggo/files"     // swagger embed files
        ginSwagger "github.com/swaggo/gin-swagger" // gin-swagger middleware

        "github.com/gin-gonic/gin"
)

// Init router
func Init(conf *config.Config) *gin.Engine <span class="cov0" title="0">{
        setMode()

        r := gin.New()
        r.Use(middleware.Base()...)
        jwt := jwt.Jwt(&amp;conf.Jwt)
        svcCtx := service.NewServiceContext(conf)

        </span><span class="cov0" title="0">{
                user := controller.NewUserController(svcCtx)
                r := r.Group("/api/v1/user")

                r.POST("/login", user.Login)
        }</span>
        <span class="cov0" title="0">{
                wallet := controller.NewWalletController(svcCtx)
                r := r.Group("/api/v1/wallet")

                r.POST("/deposit", jwt, wallet.Deposit)
                r.POST("/withdraw", jwt, wallet.Withdraw)
                r.POST("/transfer", jwt, wallet.Transfer)
                r.GET("/balance", jwt, wallet.Balance)
                r.GET("/record", jwt, wallet.Record)
        }</span>

        <span class="cov0" title="0">r.GET("/swagger/*any", ginSwagger.DisablingWrapHandler(swaggerFiles.Handler, "DISABLE_SWAGGER"))

        return r</span>
}

func setMode() <span class="cov0" title="0">{
        runMode := "release"
        if env := os.Getenv("GO_MODE"); env == "debug" </span><span class="cov0" title="0">{
                runMode = "debug"
        }</span>
        <span class="cov0" title="0">gin.SetMode(runMode)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "wallet/internal/config"
        "wallet/internal/dao"
)

type ServiceContext struct {
        Config          *config.Config
        Dao             *dao.Dao
        UserDao         *dao.User
        WalletDao       *dao.Wallet
        WalletRecordDao *dao.WalletRecord
}

func NewServiceContext(c *config.Config) *ServiceContext <span class="cov8" title="1">{
        d := dao.NewDao(c)
        return &amp;ServiceContext{
                Config:          c,
                Dao:             d,
                UserDao:         dao.NewUser(d),
                WalletDao:       dao.NewWallet(d),
                WalletRecordDao: dao.NewWalletRecord(d),
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "wallet/internal/consts"
        "wallet/internal/gin/middleware/jwt"
        "wallet/internal/types"
        "wallet/pkg/e"

        "github.com/gin-gonic/gin"
)

type userService struct {
        ctx    *gin.Context
        svcCtx *ServiceContext
}

func NewUserService(ctx *gin.Context, svcCtx *ServiceContext) *userService <span class="cov8" title="1">{
        return &amp;userService{
                ctx:    ctx,
                svcCtx: svcCtx,
        }
}</span>

func (svc *userService) Login(email, password string) (*types.UserLoginOutput, e.Codes) <span class="cov8" title="1">{
        userInfo, err := svc.svcCtx.UserDao.FindOneByEmail(svc.ctx, email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if userInfo.Status == consts.UserStatusInactive </span><span class="cov0" title="0">{
                return nil, e.UserNotActive
        }</span>

        <span class="cov8" title="1">if userInfo.Password != password </span><span class="cov8" title="1">{
                return nil, e.UsernameOrPasswordErr
        }</span>

        <span class="cov8" title="1">outputInfo := &amp;types.UserInfo{
                ID:        userInfo.ID,
                Email:     userInfo.Email,
                FirstName: userInfo.FirstName,
                LastName:  userInfo.LastName,
                Gender:    userInfo.Gender,
                Status:    userInfo.Status,
                CreatedAt: userInfo.CreatedAt,
        }

        token, err2 := jwt.Sign(&amp;svc.svcCtx.Config.Jwt, outputInfo)
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, e.Cause(err2)
        }</span>

        <span class="cov8" title="1">output := &amp;types.UserLoginOutput{
                Token: token,
                Info:  outputInfo,
        }

        return output, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "context"
        "fmt"
        "wallet/internal/consts"
        "wallet/internal/model"
        "wallet/internal/types"
        "wallet/pkg/e"

        "github.com/gin-gonic/gin"
)

type walletService struct {
        ctx    *gin.Context
        svcCtx *ServiceContext
}

func NewWalletService(ctx *gin.Context, svcCtx *ServiceContext) *walletService <span class="cov8" title="1">{
        return &amp;walletService{
                ctx:    ctx,
                svcCtx: svcCtx,
        }
}</span>

func (svc *walletService) Deposit(in *types.DepositInput) e.Codes <span class="cov8" title="1">{
        if err := svc.svcCtx.Dao.Transaction(svc.ctx, func(ctx context.Context) e.Codes </span><span class="cov8" title="1">{
                walletInfo, err := svc.svcCtx.WalletDao.FindOneByUserIDForUpdate(ctx, in.UserID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">newBalance := walletInfo.Balance + in.Amount
                if err := svc.svcCtx.WalletDao.UpdateBalanceByUserID(ctx, in.UserID, newBalance); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">describe := fmt.Sprintf("Deposit %.2f", in.Amount)
                walletRecord := &amp;model.WalletRecord{
                        WalletID:        walletInfo.ID,
                        Amount:          in.Amount,
                        TransactionType: consts.WalletRecordTypeIncome,
                        Describe:        &amp;describe,
                }
                // Transaction records
                if err := svc.svcCtx.WalletRecordDao.Create(ctx, walletRecord); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (svc *walletService) Withdraw(in *types.WithdrawInput) e.Codes <span class="cov8" title="1">{
        if err := svc.svcCtx.Dao.Transaction(svc.ctx, func(ctx context.Context) e.Codes </span><span class="cov8" title="1">{
                walletInfo, err := svc.svcCtx.WalletDao.FindOneByUserIDForUpdate(ctx, in.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">newBalance := walletInfo.Balance - in.Amount

                // Determine the balance is sufficient
                if newBalance &lt; 0 </span><span class="cov8" title="1">{
                        return e.InsufficientFunds
                }</span>
                <span class="cov8" title="1">if err := svc.svcCtx.WalletDao.UpdateBalanceByUserID(ctx, in.UserID, newBalance); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">describe := fmt.Sprintf("Withdraw %.2f", in.Amount)
                walletRecord := &amp;model.WalletRecord{
                        WalletID:        walletInfo.ID,
                        Amount:          in.Amount,
                        TransactionType: consts.WalletRecordTypeExpend,
                        Describe:        &amp;describe,
                }
                // Transaction records
                if err := svc.svcCtx.WalletRecordDao.Create(ctx, walletRecord); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (svc *walletService) Transfer(in *types.TransferInput) e.Codes <span class="cov8" title="1">{
        if in.UserID == in.TargetUserID </span><span class="cov0" title="0">{
                return e.UserDuplicate
        }</span>

        <span class="cov8" title="1">targetUserInfo, err := svc.svcCtx.UserDao.FindOneByID(svc.ctx, in.TargetUserID)
        if err != nil </span><span class="cov0" title="0">{
                return e.UserNotExist
        }</span>

        <span class="cov8" title="1">if err := svc.svcCtx.Dao.Transaction(svc.ctx, func(ctx context.Context) e.Codes </span><span class="cov8" title="1">{
                // Get the wallet information for both users and wait for update
                walletInfo, err := svc.svcCtx.WalletDao.FindOneByUserIDForUpdate(ctx, in.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">targetWalletInfo, err := svc.svcCtx.WalletDao.FindOneByUserIDForUpdate(ctx, in.TargetUserID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">newBalance := walletInfo.Balance - in.Amount
                // Determine the balance is sufficient
                if newBalance &lt; 0 </span><span class="cov0" title="0">{
                        return e.InsufficientFunds
                }</span>
                // Update the user's balance
                <span class="cov8" title="1">if err := svc.svcCtx.WalletDao.UpdateBalanceByUserID(ctx, in.UserID, newBalance); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">targetNewBalance := targetWalletInfo.Balance + in.Amount
                // Update the target user's balance
                if err := svc.svcCtx.WalletDao.UpdateBalanceByUserID(ctx, in.TargetUserID, targetNewBalance); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">describe := fmt.Sprintf("Transfer %.2f to the user [%s %s]", in.Amount, targetUserInfo.FirstName, targetUserInfo.LastName)
                walletRecord := &amp;model.WalletRecord{
                        WalletID:        walletInfo.ID,
                        Amount:          in.Amount,
                        TransactionType: consts.WalletRecordTypeExpend,
                        Describe:        &amp;describe,
                }
                // Transaction records
                if err := svc.svcCtx.WalletRecordDao.Create(ctx, walletRecord); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">targetDescribe := fmt.Sprintf("Received a transfer of %.2f from [%s %s]", in.Amount, in.FirstName, in.LastName)
                targetWalletRecord := &amp;model.WalletRecord{
                        WalletID:        targetWalletInfo.ID,
                        Amount:          in.Amount,
                        TransactionType: consts.WalletRecordTypeIncome,
                        Describe:        &amp;targetDescribe,
                }
                // Transaction records
                if err := svc.svcCtx.WalletRecordDao.Create(ctx, targetWalletRecord); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (svc *walletService) Balance(in *types.BalanceInput) (*types.BalanceOutput, e.Codes) <span class="cov8" title="1">{
        walletInfo, err := svc.svcCtx.WalletDao.FindOneByUserID(svc.ctx, in.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output := &amp;types.BalanceOutput{
                UserID:  in.UserID,
                Balance: walletInfo.Balance,
        }

        return output, nil</span>
}

func (svc *walletService) Record(in *types.RecordInput) ([]*types.RecordOutput, int64, e.Codes) <span class="cov8" title="1">{
        walletInfo, err := svc.svcCtx.WalletDao.FindOneByUserID(svc.ctx, in.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">walletRecordList, total, err := svc.svcCtx.WalletRecordDao.FindListAndCountByWalletID(svc.ctx, walletInfo.ID, in.Offset, in.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">var output []*types.RecordOutput
        for _, record := range walletRecordList </span><span class="cov8" title="1">{
                output = append(output, &amp;types.RecordOutput{
                        ID:              record.ID,
                        TransactionType: record.TransactionType,
                        Amount:          record.Amount,
                        Describe:        record.Describe,
                        CreatedAt:       record.CreatedAt,
                })
        }</span>

        <span class="cov8" title="1">return output, total, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package utils

// GetOffsetLimit get offset and limit
func GetOffsetLimit(page int64, size int64) (int64, int64) <span class="cov8" title="1">{
        if page &lt;= 0 </span><span class="cov8" title="1">{
                page = 1
        }</span>
        <span class="cov8" title="1">if size &lt;= 0 </span><span class="cov8" title="1">{
                size = 10
        }</span>

        <span class="cov8" title="1">var limit int64 = 1
        if size &gt; 1 </span><span class="cov8" title="1">{
                limit = size
        }</span>

        <span class="cov8" title="1">offset := (page - 1) * limit

        return offset, limit</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package main

import (
        "context"
        "crypto/tls"
        "flag"
        "fmt"

        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
        "wallet/internal/config"
        "wallet/internal/router"
        "wallet/pkg/config/setting"
        "wallet/pkg/logger"
)

var configFile = flag.String("f", "etc/config.yaml", "config file")

// @title wallet
// @version 1.0.0
// @description wallet
// @host 127.0.0.1:3000
// @BasePath /api/v1
// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization
// @description Please enter your Bearer token
func main() <span class="cov0" title="0">{
        flag.Parse()

        var conf config.Config
        setting.New(*configFile).Setup(&amp;conf)

        logger.Init(nil)

        // cwd, _ := os.Getwd()
        // migrationsPath := filepath.Join(cwd, "etc", "migrations")
        // dao.Init(conf, migrationsPath)

        endPoint := fmt.Sprintf(":%d", conf.Server.Port)
        maxHeaderBytes := 1 &lt;&lt; 20

        routersInit := router.Init(&amp;conf)

        server := &amp;http.Server{
                Addr:           endPoint,
                Handler:        routersInit,
                ReadTimeout:    60 * time.Second,
                WriteTimeout:   60 * time.Second,
                MaxHeaderBytes: maxHeaderBytes,
                TLSConfig: &amp;tls.Config{
                        InsecureSkipVerify: true,
                },
        }

        go func() </span><span class="cov0" title="0">{
                logger.Infof("service start sucessful and listening on port :%s ...", endPoint)
                // service connections
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Fatalf("listen: %s\n", err.Error())
                }</span>
        }()

        // go func() {
        //         log.Println(http.ListenAndServe("localhost:10000", nil))
        // }()

        // Wait for interrupt signal to gracefully shutdown the server with
        // a timeout of 5 seconds.
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        // kill (no param) default send syscall.SIGTERM
        // kill -2 is syscall.SIGINT
        // kill -9 is syscall.SIGKILL but can't be catch, so don't need add it
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        logger.Info("Shutdown Server ...")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Server Shutdown: %s\n", err.Error())
        }</span>

        <span class="cov0" title="0">logger.Info("Server exiting")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package setting

import (
        "fmt"

        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
        "github.com/spf13/viper"
)

// Setting .
type Setting struct {
        paths []string
}

// New Setting
func New(paths ...string) (s *Setting) <span class="cov0" title="0">{
        s = &amp;Setting{
                paths: paths,
        }

        return
}</span>

// Setup .
func (s *Setting) Setup(config interface{}) <span class="cov0" title="0">{
        for _, path := range s.paths </span><span class="cov0" title="0">{
                viper.SetConfigFile(path)

                if err := viper.MergeInConfig(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Setup merge in config error %s", err.Error())
                        panic(err)</span>
                }
        }

        <span class="cov0" title="0">err := loadParseConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Load parse config error %s", err.Error())
                panic(err)</span>
        }
}

func loadParseConfig(config interface{}) error <span class="cov0" title="0">{
        if err := mapstructure.Decode(viper.AllSettings(), config); err != nil </span><span class="cov0" title="0">{
                return errors.WithStack(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package e

import (
        "fmt"
        "strconv"
        "sync/atomic"

        "github.com/pkg/errors"
)

var (
        _messages    atomic.Value // NOTE: stored map[string]map[int]string
        _codes       = map[int]struct{}{}
        _defaultI18n = "en-us"
)

// Register register ecode message map.
func Register(i18n string, e Code, msg string) <span class="cov8" title="1">{
        all, ok := _messages.Load().(map[string]map[int]string)
        if !ok </span><span class="cov8" title="1">{
                all = make(map[string]map[int]string)
        }</span>

        <span class="cov8" title="1">if _, ok := all[i18n]; !ok </span><span class="cov8" title="1">{
                msgs := make(map[int]string)
                all[i18n] = msgs
        }</span>
        <span class="cov8" title="1">all[i18n][e.Code()] = msg
        _messages.Store(all)</span>
}

// SetDefault .
func SetDefault(i18n string) <span class="cov8" title="1">{
        _defaultI18n = i18n
}</span>

// NewCode .
func NewCode(e int) Code <span class="cov8" title="1">{
        if e &lt;= 0 </span><span class="cov8" title="1">{
                panic("e code must greater than zero")</span>
        }
        <span class="cov8" title="1">return add(e)</span>
}

func add(e int) Code <span class="cov8" title="1">{
        if _, ok := _codes[e]; ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("ecode: %d already exist", e))</span>
        }
        <span class="cov8" title="1">_codes[e] = struct{}{}
        return Int(e)</span>
}

// Codes ecode error interface which has a code &amp; message.
type Codes interface {
        // sometimes Error return Code in string form
        Error() string
        // Code get error code.
        Code() int
        // Message get code message.
        Message() string

        US(string) Code
}

// A Code is an int error code spec.
type Code int

func (e Code) Error() string <span class="cov8" title="1">{
        return strconv.FormatInt(int64(e), 10)
}</span>

// Code return error code
func (e Code) Code() int <span class="cov8" title="1">{ return int(e) }</span>

// Message return error message
func (e Code) Message() string <span class="cov8" title="1">{
        if all, ok := _messages.Load().(map[string]map[int]string); ok </span><span class="cov8" title="1">{
                if msgs, ok := all[_defaultI18n]; ok </span><span class="cov8" title="1">{
                        if msg, ok := msgs[e.Code()]; ok </span><span class="cov8" title="1">{
                                return msg
                        }</span>
                }
        }

        <span class="cov8" title="1">return e.Error()</span>
}

// Messagef .
func (e Code) Messagef(i18n string) string <span class="cov0" title="0">{
        if all, ok := _messages.Load().(map[string]map[int]string); ok </span><span class="cov0" title="0">{
                msgs, ok := all[i18n]
                if !ok </span><span class="cov0" title="0">{
                        msgs, ok = all[_defaultI18n]
                }</span>

                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                        if msg, ok := msgs[e.Code()]; ok </span><span class="cov0" title="0">{
                                return msg
                        }</span>
                }
        }

        <span class="cov0" title="0">return e.Error()</span>
}

// Details return details.
func (e Code) Details() []interface{} <span class="cov0" title="0">{ return nil }</span>

// US .
func (e Code) US(msg string) Code <span class="cov8" title="1">{
        Register("en-us", e, msg)
        return e
}</span>

// Int parse code int to error.
func Int(i int) Code <span class="cov8" title="1">{ return Code(i) }</span>

// String parse code string to error.
func String(e string) Code <span class="cov8" title="1">{
        if e == "" </span><span class="cov0" title="0">{
                return OK
        }</span>
        // try error string
        <span class="cov8" title="1">i, err := strconv.Atoi(e)
        if err != nil </span><span class="cov8" title="1">{
                return ServerErr
        }</span>
        <span class="cov8" title="1">return Code(i)</span>
}

// Cause cause from error to ecode.
func Cause(e error) Codes <span class="cov8" title="1">{
        if e == nil </span><span class="cov0" title="0">{
                return OK
        }</span>
        <span class="cov8" title="1">ec, ok := errors.Cause(e).(Codes)
        if ok </span><span class="cov8" title="1">{
                return ec
        }</span>
        <span class="cov8" title="1">return String(e.Error())</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package e

import (
        "fmt"
        "strconv"

        "github.com/pkg/errors"
)

var _ Codes = &amp;E{}

// E is a Custom error message
// implement ecode.Codes
type E struct {
        code Code
        err  error // Custom errors
}

// New a E
func New(code Code, err error) Codes <span class="cov8" title="1">{
        return &amp;E{code, errors.WithStack(err)}
}</span>

// NewI a E
func NewI(code int, err error) Codes <span class="cov8" title="1">{
        return &amp;E{Int(code), errors.WithStack(err)}
}</span>

// Error implement error
func (e *E) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Error: %s, Code: %d, Message: %s", e.err.Error(), e.Code(), e.Message())
}</span>

// Code return error code
func (e *E) Code() int <span class="cov8" title="1">{
        return int(e.code.Code())
}</span>

// Message return error message for developer
func (e *E) Message() string <span class="cov8" title="1">{
        if e.err != nil </span><span class="cov8" title="1">{
                return e.err.Error() // Prefer custom error messages
        }</span>
        <span class="cov8" title="1">if e.code.Message() == "" </span><span class="cov0" title="0">{
                return strconv.Itoa(e.code.Code())
        }</span>
        <span class="cov8" title="1">return e.code.Message()</span>
}

// US .
func (e *E) US(msg string) Code <span class="cov0" title="0">{
        Register("en-us", Code(e.Code()), msg)
        return Code(e.Code())
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package jwt

import (
        "crypto/md5"
        "fmt"

        "github.com/golang-jwt/jwt/v5"
)

// Config conf
type Config struct {
        Secret string `json:"secret"`
        Exp    int    `json:"exp"` // hours
}

// ClaimsWrap .
type ClaimsWrap struct {
        jwt.Claims
        Config
}

// ClaimsWraper .
type ClaimsWraper interface {
        GetSignKey() []byte
        Sign() (string, error)
        Parse(tokenString string) (*jwt.Token, error)
}

// New ClaimsWraper
func New(claims jwt.Claims, config Config) ClaimsWraper <span class="cov8" title="1">{
        return &amp;ClaimsWrap{claims, config}
}</span>

// GetSignKey .
func (c *ClaimsWrap) GetSignKey() []byte <span class="cov8" title="1">{
        s := fmt.Sprintf("%x", md5.Sum([]byte(c.Secret)))
        return []byte(s)
}</span>

// Sign .
func (c *ClaimsWrap) Sign() (string, error) <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, c.Claims)
        s, err := token.SignedString(c.GetSignKey())
        return s, err
}</span>

// Parse .
func (c *ClaimsWrap) Parse(tokenString string) (*jwt.Token, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, c.Claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return c.GetSignKey(), nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if token.Valid </span><span class="cov8" title="1">{
                return token, nil
        }</span>

        <span class="cov0" title="0">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package logger

import "go.uber.org/zap/zapcore"

type LevelConf struct {
        Level      string // level
        Path       string // The path of the log file
        MaxSize    int    // The maximum size of each log file saved unit：M
        MaxBackups int    // How many backups can be saved for log files at most
        MaxAge     int    // How many days can the file be saved
        Compress   bool   // Whether to compress
        LocalTime  bool
}

func DefaultLevelConf() []LevelConf <span class="cov8" title="1">{
        return []LevelConf{
                {
                        Level:      "debug",
                        Path:       "logs/debug.log",
                        MaxSize:    50,
                        MaxBackups: 30,
                        MaxAge:     30,
                        Compress:   true,
                        LocalTime:  false,
                },
                {
                        Level:      "info",
                        Path:       "logs/info.log",
                        MaxSize:    50,
                        MaxBackups: 30,
                        MaxAge:     30,
                        Compress:   true,
                        LocalTime:  false,
                },
                {
                        Level:      "warn",
                        Path:       "logs/error.log",
                        MaxSize:    50,
                        MaxBackups: 30,
                        MaxAge:     360,
                        Compress:   true,
                        LocalTime:  false,
                },
        }
}</span>

func zapLevel(l string) zapcore.LevelEnabler <span class="cov8" title="1">{
        switch l </span>{
        case "debug":<span class="cov8" title="1">
                return zapcore.DebugLevel</span>
        case "info":<span class="cov8" title="1">
                return zapcore.InfoLevel</span>
        case "warn":<span class="cov8" title="1">
                return zapcore.WarnLevel</span>
        case "error":<span class="cov8" title="1">
                return zapcore.ErrorLevel</span>
        case "dpanic":<span class="cov8" title="1">
                return zapcore.DPanicLevel</span>
        case "panic":<span class="cov8" title="1">
                return zapcore.PanicLevel</span>
        case "fatal":<span class="cov8" title="1">
                return zapcore.FatalLevel</span>
        default:<span class="cov8" title="1">
                return zapcore.InfoLevel</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package logger

type Config struct {
        EnableConsole bool
        Levels        []LevelConf
}

func setConfig(conf *Config) <span class="cov8" title="1">{
        if conf.Levels == nil </span><span class="cov8" title="1">{
                conf.Levels = DefaultLevelConf()
        }</span>
}

func Init(conf *Config) <span class="cov8" title="1">{
        if conf == nil </span><span class="cov0" title="0">{
                conf = &amp;Config{}
        }</span>
        <span class="cov8" title="1">setConfig(conf)

        zapBuilder := NewZapBuilder(conf.Levels)
        if conf.EnableConsole </span><span class="cov8" title="1">{
                zapBuilder.EnableConsole()
        }</span>

        <span class="cov8" title="1">logger := zapBuilder.Build()
        SetLogger(logger)</span>
}

func Debug(args ...interface{}) <span class="cov8" title="1">{
        Logger.Debug(args...)
}</span>
func Debugf(template string, args ...interface{}) <span class="cov8" title="1">{
        Logger.Debugf(template, args...)
}</span>

func Info(args ...interface{}) <span class="cov8" title="1">{
        Logger.Info(args...)
}</span>
func Infof(template string, args ...interface{}) <span class="cov8" title="1">{
        Logger.Infof(template, args...)
}</span>

func Warn(args ...interface{}) <span class="cov8" title="1">{
        Logger.Warn(args...)
}</span>
func Warnf(template string, args ...interface{}) <span class="cov8" title="1">{
        Logger.Warnf(template, args...)
}</span>

func Error(args ...interface{}) <span class="cov8" title="1">{
        Logger.Error(args...)
}</span>
func Errorf(template string, args ...interface{}) <span class="cov8" title="1">{
        Logger.Errorf(template, args...)
}</span>

func DPanic(args ...interface{}) <span class="cov0" title="0">{
        Logger.DPanic(args...)
}</span>
func DPanicf(template string, args ...interface{}) <span class="cov0" title="0">{
        Logger.DPanicf(template, args...)
}</span>

func Panic(args ...interface{}) <span class="cov0" title="0">{
        Logger.Panic(args...)
}</span>
func Panicf(template string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Panicf(template, args...)
}</span>

// Fatal logs a message, then calls os.Exit(1).
func Fatal(args ...interface{}) <span class="cov0" title="0">{
        Logger.Fatal(args...)
}</span>
func Fatalf(template string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Fatalf(template, args...)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package logger

import (
        "os"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
)

// hooksConfig .
type hooksConfig struct {
        hook  lumberjack.Logger
        level zapcore.LevelEnabler
}

// ZapBuilder .
type ZapBuilder struct {
        hooks         []hooksConfig
        fileEnable    bool
        consoleEnable bool
        consoleLevel  zapcore.LevelEnabler
}

// NewZapBuilder .
func NewZapBuilder(confs []LevelConf) *ZapBuilder <span class="cov8" title="1">{
        if confs == nil </span><span class="cov8" title="1">{
                confs = DefaultLevelConf()
        }</span>
        <span class="cov8" title="1">var hooks []hooksConfig
        for _, conf := range confs </span><span class="cov8" title="1">{
                hooks = append(hooks, hooksConfig{
                        hook: lumberjack.Logger{
                                Filename:   conf.Path,
                                MaxSize:    conf.MaxSize,
                                MaxBackups: conf.MaxBackups,
                                MaxAge:     conf.MaxAge,
                                Compress:   conf.Compress,
                                LocalTime:  conf.LocalTime,
                        },
                        level: zapLevel(conf.Level),
                })
        }</span>

        <span class="cov8" title="1">return &amp;ZapBuilder{
                hooks:         hooks,
                fileEnable:    false,
                consoleEnable: true,
                consoleLevel:  zapcore.DebugLevel,
        }</span>
}

// DisableFile .
func (opts *ZapBuilder) DisableFile() *ZapBuilder <span class="cov8" title="1">{
        opts.fileEnable = false
        return opts
}</span>

// EnableConsole .
func (opts *ZapBuilder) EnableConsole() *ZapBuilder <span class="cov8" title="1">{
        opts.consoleEnable = true
        return opts
}</span>

// Build .
func (zb *ZapBuilder) Build() *zap.Logger <span class="cov8" title="1">{
        var (
                cores []zapcore.Core
                opts  []zap.Option
        )

        encoderConfig := zapcore.EncoderConfig{
                TimeKey:        "time",
                LevelKey:       "level",
                NameKey:        "name",
                CallerKey:      "caller",
                MessageKey:     "message",
                StacktraceKey:  "stacktrace",
                FunctionKey:    "function",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.CapitalLevelEncoder, // Uppercase encoder
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
                EncodeName:     zapcore.FullNameEncoder,
        }

        if zb.fileEnable </span><span class="cov0" title="0">{
                for i, l := 0, len(zb.hooks); i &lt; l; i++ </span><span class="cov0" title="0">{
                        hook := &amp;zb.hooks[i].hook
                        fileW := zapcore.AddSync(hook)
                        core := zapcore.NewCore(zapcore.NewJSONEncoder(encoderConfig), fileW, zb.hooks[i].level)
                        cores = append(cores, core)
                }</span>
        }

        <span class="cov8" title="1">if zb.consoleEnable </span><span class="cov8" title="1">{
                encoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
                encoderConfig.EncodeTime = func(t time.Time, enc zapcore.PrimitiveArrayEncoder) </span><span class="cov8" title="1">{
                        enc.AppendString(t.Format("2006-01-02 15:04:05.000"))
                }</span>
                <span class="cov8" title="1">consoleW := zapcore.Lock(os.Stdout)
                core := zapcore.NewCore(zapcore.NewConsoleEncoder(encoderConfig), consoleW, zb.consoleLevel)
                cores = append(cores, core)</span>
        }
        // else if zb.serverName != "" {
        //         // Add custom fields serverName
        //         opts = append(opts, zap.Fields(zap.String("ServerName", zb.serverName)))
        // }

        // Open the file and line number
        <span class="cov8" title="1">opts = append(opts, zap.AddCaller(), zap.AddCallerSkip(1))

        core := zapcore.NewTee(cores...)
        return zap.New(core, opts...)</span>
}

var (
        // Desugar .
        Desugar *zap.Logger
        // Logger .
        Logger *zap.SugaredLogger
)

// SetLogger .
func SetLogger(logger *zap.Logger) <span class="cov8" title="1">{
        Desugar = logger
        Logger = logger.Sugar()
}</span>

func init() <span class="cov8" title="1">{
        Desugar = NewZapBuilder(nil).Build()
        Logger = Desugar.Sugar()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
